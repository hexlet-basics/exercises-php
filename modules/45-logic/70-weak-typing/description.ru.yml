---

name: Слабая типизация
theory: |

  В модуле «Арифметика» мы затронули тему слабой типизации.

  PHP — это язык со **слабой типизацией**. Он знает о существовании разных типов (числа, строки и др.), но относится к их использованию не очень строго, пытаясь преобразовывать информацию, когда это кажется разумным.

  Особенно много автоматических преобразований происходит при работе с логическими операциями.

  Пример:

  ```php
  <?php

  print_r(0 || 1);
  ```

  <pre class='hexlet-basics-output'>1</pre>

  Что тут произошло:

  1. Оператор **ИЛИ** работает только с типом *bool*, но ему даны числа `1` и `0`.
  2. `0` преобразуется в `false`, а `1` преобразуется в `true`.
  3. Результат `false || true` — это `true`
  4. Теперь `print_r` получает `true`, но он работает только со строками, а не *bool*.
  5. `true` преобразуется в `1`.
  6. На экран выводится `1`.

  В PHP есть два простых правила, по которым происходят преобразования:

  * `0`, `''`, `null` превращаются в `false`
  * Всё остальное превращается в `true`

  Это работает и в другую сторону: `true` и `false` преобразовываются в другие типы данных, в зависимости от ситуации:

  ```php
  <?php

  print_r(true);
  ```

  <pre class='hexlet-basics-output'>1</pre>

  ```php
  <?php

  print_r(false);
  ```

  <pre class='hexlet-basics-output'></pre>

  *(на экран вывелась пустая строка)*

  ---

  В одном из уроков мы рассмотрели операторы сравнения `===` и `!==` и упомянули, что в PHP также есть операторы `==` и `!=`, но их не стоит использовать. Отличия как раз заключаются в преобразовании типов:

  ```php
  var_dump('' === false); // => false
  var_dump('' == false);  // => true
  ```

  Пустая строка и `false` — это разные значения, поэтому оператор `===` говорит «ложь! они не равны!».

  Но оператор `==` преобразует типы, и с его точки зрения пустая строка и `false` равны.

  Это преобразование неявное, поэтому по возможности избегайте операторов `==` и `!=`.

  ---

  Вспомните операцию отрицания:

  ```php
  $answer = true;
  var_dump(!$answer); // => false
  ```

  При двойном отрицании `!!` итоговое значение равно начальному:

  ```php
  $answer = true;
  var_dump(!!$answer); // => true
  ```

  Но здесь дополнительно происходят преобразования типа. Поэтому результатом двойного отрицания всегда будет _bool_. Этим приемом пользуются, чтобы поменять тип данных.

  ---

  В разных языках программирования разные правила преобразований. Некоторые языки вообще не преобразовывают типы сами. Многие особенности PHP откровенно не самые удачные, но это историческое наследие языка. Если бы его создавали сегодня с нуля, то многие правила и нюансы наверняка были бы совсем иными.

instructions: |

  Напишите функцию `isFalsy`, которая проверяет, трактуется ли переданное значение как ложное с точки зрения PHP. Для выполнения этой проверки вам понадобится сравнить `false` с переданным значением, используя `==`.

  ```php
  <?php

  isFalsy(false);  // true
  isFalsy(0);      // true
  isFalsy('help'); // false
  isFalsy(10);     // false
  ```

tips:
  - |
    [Booleans](http://php.net/manual/ru/language.types.boolean.php)
